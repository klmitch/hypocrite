=====================
C Unit Test Generator
=====================

.. image:: https://travis-ci.org/klmitch/hypocrite.svg?branch=master
    :target: https://travis-ci.org/klmitch/hypocrite

Hypocrite is a system for generating compilable unit tests for C
programs.  These unit tests support mocking C functions utilizing
macros, which allows mocking functions contained within a C source
file, in addition to library functions.  Additionally, fixtures are
supported, allowing multiple tests to set up the same environment, as
well as allowing fixtures to be cleaned up after a test, regardless of
how the test exits.

Hypocrite Input File
====================

The Hypocrite input file is in a specialized format referred to as a
"percent" file; that is, the file consists solely of comments (both
C++-style and C-style comments are recognized) and directives
beginning with the '%' character.  Several of the defined directives
take code blocks, which are introduced with a '{' character at the end
of the directive line, and end at a '%}' sequence at the beginning of
a following line.  One directive, the '%fixture' directive, has an
optional block that is introduced by following the '%}' sequence with
the keyword "teardown" and another '{' character.  Each of the
recognized directives are documented in the following sections.

The ``%target`` Directive
-------------------------

The ``%target`` directive takes a string, delimited with double
quotes, naming the source file that is being tested.  This will result
in an ``#include`` preprocessor directive in the generated test file.
This is the only directive that is required.  For example::

    %target "example.c"

The ``%preamble`` Directive
---------------------------

The generated C source files contain, at the beginning, several data
type and function definitions specific to Hypocrite testing.  After
that, the developer has the ability to include "preamble" code
containing includes and definitions specific to the actual tests; this
is done using the ``%preamble`` directive.  It is highly recommended
that a ``%preamble`` directive be used to include any headers that
appear in the source file (named in the ``%target`` directive), as the
macros generated by Hypocrite for mocking the functions contained
therein may interfere with the headers.  Note that this assumes that
the headers are idempotent; if a header must be included which is not
idempotent, the developer should place a guard around the include,
e.g., use something like the following in the source file::

    #ifndef EXAMPLE_TEST
    #include <non-idempotent.h>
    #endif

The following is an example of a ``%preamble`` directive::

    %preamble {
    #include "example.h"
    %}

Note that, although tests are currently run sequentially, future work
may execute each test in its own address space utilizing ``fork()``,
so it is good practice to ensure that each test is completely
independent of every other test, and to avoid relying on global values
specified in a ``%preamble`` to allow tests to communicate with each
other.

The ``%mock`` Directive
-----------------------

A "mock" is a function defined with the same interface as the real
function, but which may be configured to capture any call arguments
and to produce any desired output.  Consider the case of testing a
function that calls ``malloc()``; any consumer of ``malloc()`` must be
prepared for it to return ``NULL``, but how would a test author check
that the behavior is correct?  By declaring a mock, the test author
can force ``malloc()`` to return ``NULL``, thus allowing the test to
confirm that the behavior is correct.

The ``%mock`` directive is used to declare mocks.  It should contain a
C-compatible function declaration describing the arguments the
function should take, as well as the expected return type of the
function, e.g.::

    %mock void *malloc(size_t size)
    %mock void free(void *ptr)

Note that the type parser used by Hypocrite is not a fully C-compliant
parser.  In particular, every argument must be named (this is required
anyway in order to create the structures that record the call
arguments), and all the types must be of a form such that the argument
name is the last token.  This means that functions that take function
pointers, or which return function pointers, *must* use ``typedef``
declarations of those functions; if the included header files don't
specify such a ``typedef``, create one in the ``%preamble`` section.
For instance, the ``qsort()`` function takes a pointer to a function
that receives two ``const void`` pointers and returns an ``int``; to
mock this function, a developer could use::

    %preamble {
    typedef int (*compare_t)(const void *, const void *);
    %}

    %mock void qsort(void *base, size_t nmemb, size_t size, compare_t comp)

The ``%fixture`` Directive
--------------------------

Fixtures set up, and optionally tear down, some element of the
environment which a test may require.  Fixtures may simply do the
work, or they may return a value, which may in turn be passed to a
test function utilizing them.  For instance::

    %fixture clear_count {
      some_count = 0;
    %}

In this example, a fixture named "clear_count" is defined which simply
sets the global variable "some_count" to 0.  (It is presumed that this
variable is either a global variable from the source file--remember,
it is included in the generated test file--or a global variable
defined in a ``%preamble``.)

Most fixtures actually need to clean up after themselves, and some may
even return a value that will then be used by the test function.  In
our contrived "clear_count" fixture above, this could look like::

    %fixture int clear_count {
      int save_count = some_count;

      some_count = 0;

      return save_count;
    %} teardown {
      some_count = clear_count;
    %}

In this example, we see that the "clear_count" fixture is declared
with an ``int``, and additionally has a ``return`` statement.
Everywhere this returned value is injected--such as in a test, or, in
this case, in the ``teardown`` clause--the value will have the name of
the fixture.  Thus, in this ``teardown`` clause, we see that our
``some_count`` variable is set to the value of ``clear_count``, which
will be the value in the ``return`` statement.

It should be noted that the ``%fixture`` directive is realized in the
generated file after mocks have been "uninstalled", so it is safe to
use mocked functions directly without upsetting the mocks for the
tests.  Thus, even if, for example, ``malloc()`` and ``free()`` were
mocked in the input file, those functions may still be used directly.
Also note that both the main code block and the ``teardown`` code
block are turned into functions in the generated file.

The ``%test`` Directive
-----------------------

A test is where the rubber meets the road.  Each ``%test`` directive
has a name, an optional list of fixtures, and the actual code to
perform the test.  Several special functions and macros are provided
to interact with Hypocrite, such as the ``hypo_assert()`` macro, as
well as functions and macros for interacting with mocks, such as
``hypo_mock_addreturn_XXX()``.  (Each of these is documented below in
the `Writing Unit Tests`_ section.)  Like a ``%fixture``, the code
block of a test is realized as a function in the generated file.

The simplest kind of test needs no fixtures::

    %test check_count {
      hypo_assert(some_count == 42);
    %}

To instruct Hypocrite to use one or more fixtures for a particular
test, list the fixture names--separated by commas and between
parentheses--after the test name; e.g.::

    %test check_count2(clear_count, other_fixture) {
      hypo_assert(some_count == 0);
      hypo_assert(clear_count == 42);
    %}

Sometimes, a fixture returns a value, perhaps for use with its
``teardown`` code, but a given test does not actually need the value
of the fixture.  Injection of the fixture return value may be
inhibited by preceding the fixture name with the "!" character, e.g.::

    %test check_count3(!clear_count) {
      hypo_assert(some_count == 0);
    %}

Hypocrite is intelligent enough to not attempt to inject fixtures that
return no values; in such cases, the "!" is unnecessary, but no harm
is done if it is included.

Writing Unit Tests
==================

A unit testing framework is not very useful if one is not able to
actually write unit tests.  In this section, the functions and macros
available to use in tests will be discussed.

Basic Assertions
----------------

Several macros are available for performing assertions.  There are two
basic flavors: "fatal" and "non-fatal".  A "fatal" assertion stops the
testing process immediately, and should probably only be used if the
failure indicates an unrecoverable condition, such as an unexpected
inconsistency in the global data of a library being used by the code
under test; here, it would be reasonable to assume that all other
tests in the suite may fail.  Most assertions are "non-fatal",
allowing testing to continue; this will document the full list of
issues to investigate, and may speed up the testing process as
multiple bugs may be corrected at once.

In addition to the dichotomy between "fatal" and "non-fatal"
assertions, there are also those assertions that take a "msg".  The
"msg" parameter may be used to explain what the assertion failure
actually means, something that may not be immediately obvious from
seeing the expression that was tested.  For instance, seeing that the
assertion ``result.x >= 0`` failed may not be enough to understand the
failure; the "msg" parameter may be used to clarify that the assertion
failure indicates a "Buffer underflow" condition.

The following assertion macros exist:

``hypo_assert(expr)``
    Similar to the standard C ``assert()`` macro, this assertion fails
    if ``expr`` is 0.

``hypo_assert_msg(expr, msg)``
    This is identical to the ``hypo_assert(expr)`` macro, except that
    an additional message may be emitted to clarify the meaning of an
    assertion failure.

``hypo_assert_fatal(expr)``
    A fatal version of ``hypo_assert(expr)``.

``hypo_assert_fatal_msg(expr, msg)``
    A fatal version of ``hypo_assert_msg(expr, msg)``.

``hypo_fail(msg)``
    Unlike ``hypo_assert(expr)``, this macro causes an immediate test
    failure.  This could be used to report a failure if more complex
    testing needs to be performed, such as verifying that an item
    appears somewhere in a linked list.

``hypo_fail_fatal(msg)``
    A fatal version of ``hypo_fail(msg)``.

Note that all of these macros may trigger ``return`` statements in the
event a fatal assertion has been triggered; as such, they are only
suitable for use in the test itself, or in functions that have a
return type of ``void``.  Also note that they all require a special
variable of ``hypo_context_t *``, named ``hypo_ctx``, which keeps
track of all failures encountered; if you write helper functions which
use these macros, always pass ``hypo_ctx`` to that function.  Also
note that a fatal assertion triggered in a helper function will
immediately return from that helper; however, the calling code will
continue until the next call to any of the assertion macros, at which
time it will also return.

Interacting With Mocks
----------------------

By default, mocks are initialized in "spy" mode; that is, their call
arguments are recorded, then the underlying function is called and its
return value also recorded before being returned.  To inhibit calling
the underlying function, a special function with the name
``hypo_mock_addreturn_XXX()`` may be called from a test prior to
calling the function being tested.  This function registers a return
value for the mocked function (whose name replaces the "XXX") to
return.  This "addreturn" function may be called multiple times to
register additional return values.  If the function under test calls
the mocked function more times than there are return values, the mock
will simply return the last registered return value over and over
again.

Mocked functions that return ``void``, of course, have no return
value, and thus no ``hypo_mock_addreturn_XXX()`` function.  To switch
these functions out of "spy" mode, call the ``hypo_mock_nospy_XXX()``
function instead.

Of course, recording function call arguments is not useful unless the
values of those arguments can be checked.  Each mock has a type,
``hypo_mock_expectcalls_XXX``, which is a structure which may be
initialized to indicate the calls expected to be made to the
function.  For instance, if ``malloc()`` has been mocked, the
following describes an expected call for the size of ``struct spam``::

    hypo_mock_expectcalls_malloc expected[] = {
      {0, sizeof(struct spam)}
    };

The first element of this structure is always a bit mask of "any"
flags that may be used to indicate that the exact value of a specific
argument should be ignored during testing.  These flags are always
named after the name of the function and the name of the argument.
For instance, if we want to ignore the "size" argument to
``malloc()``, we could use::

    hypo_mock_expectcalls_malloc expected[] = {
      {ANYARG_MALLOC_SIZE, 0}
    };

Of course, the ``hypo_mock_expectcalls_XXX`` structure is not useful
by itself; it must be paired with a call to the
``hypo_mock_checkcalls_XXX()`` function::

    hypo_mock_checkcalls_malloc(expected, 1);

The first argument should be a list of ``hypo_mock_expectcalls_XXX``
structures, and the second argument should be the number of calls
expected.

In some cases, it will be necessary to specifically examine the call
arguments or even return values (for mocks in spy mode).  This is
enabled using the macros ``hypo_mock_callcount_XXX()``, which returns
the number of calls made to the mock; ``hypo_mock_getreturn_XXX()``,
which retrieves the return value specified by the sole integer
argument; and ``hypo_mock_getarg_XXX()``, which retrieves the named
argument from the specified call.

For example, let's assume that we're testing a function that calls the
mocked function ``foo()``, and we want to verify that it then calls
``bar(var)``, passing the return value of ``foo()``.  This could look
like::

    hypo_assert(hypo_mock_callcount_foo() == hypo_mock_callcount_bar());
    for (int i = 0; i < hypo_mock_callcount_foo(); i++)
      hypo_assert(hypo_mock_getreturn_foo(i) == hypo_mock_getarg_bar(i, var));

In addition, a test can determine where a particular call to a mocked
function was made using the ``hypo_mock_getfile_XXX()`` and
``hypo_mock_getline_XXX()`` macros, each of which take an integer.

Note: the ``hypo_mock_getreturn_XXX()`` macro is not defined for mocks
that return ``void``.

Recommended Test Layout
-----------------------

While it is possible to write unit tests in any number of ways, it is
recommended to break your unit tests into tests which check only one
element of each function, e.g., calling the function under test only
once.  Further, a good structure is to start with variable
declarations needed for the test, followed by any test-specific setup
(such as calls to ``hypo_mock_addreturn_XXX()`` or
``hypo_mock_nospy_XXX()``), followed by the call to the function under
test, followed by all of the assertions.  For instance::

    %test alloc_outofmemory {
      /* Variable declarations */
      hypo_mock_expectcalls_malloc expected[] = {
        {0, sizeof(struct spam)}
      };
      void *result;

      /* Test specific setup */
      hypo_mock_addreturn_malloc(0);

      /* Call to the function under test */
      result = alloc_spam();

      /* Test assertions */
      hypo_assert(result == 0);
      hypo_mock_checkcalls_malloc(expected, 1);
    %}

Generating the Tests
====================

The input file is, of course, meaningless unless it can be translated
into compilable C code.  This is done by calling ``hypocrite
XXX.hypo``, where ``XXX.hypo`` of course is in the input file format
documented above.  By default, ``hypocrite`` will write valid C code
to ``XXX.c``, though this output file can be overridden with the
``-O`` option.  The ``hypocrite`` program responds to the ``--help``
option as well, so refer to that for more information about how to
invoke ``hypocrite``.

The generated C code contains a ``main()`` function, so it may be
compiled and executed as normal for C programs.  The generated program
does not take any arguments, and emits plain text strings to standard
output indicating any test failures encountered.  The return code will
be non-zero if any test failures occurred; otherwise, it will be zero
to indicate success.

Special Test Considerations
===========================

Testing ``main()``
------------------

Hypocrite defines ``main`` to a special value to ensure that a test
target containing a ``main()`` function can still be tested, without
conflicting with Hypocrite's own ``main()`` function.  This define is
set throughout all the tests, so the tests may test the ``main()``
function without having to call it something else.

Forking and Threading
---------------------

Hypocrite is currently completely synchronous; it is unable to take
into account asynchronicity introduced through the use of ``fork()``
or threading.  Therefore, it is highly recommended to mock ``fork()``
or any threading calls, and to always disable spy mode on those
functions prior to calling the functions that use those interfaces.

Mocking Functions in the Target
-------------------------------

As mentioned above, it is possible to mock functions that exist in the
target.  However, owing to Hypocrite's use of preprocessor macros for
mocking, the functions in the target file may need to be prepared
specially, by surrounding the function name in parentheses::

    void
    (_function_to_mock)(int arg1, char *arg2)
    {
      ...
    }

The parentheses around the function name ("_function_to_mock" in this
example) ensure that the macro that Hypocrite creates won't be
substituted for the function definition, which would lead to a syntax
error.  These parentheses around the function name should not be used
elsewhere within the file, as that would prevent Hypocrite from
mocking that call.

Additionally, the function to mock must be declared by a
``%preamble``, either in an ``#include`` or explicitly.  If this is
not done, the code that creates the mock will occur before the
declaration of the function to mock, resulting in a compile time
error.

Mocking Functions That Are Also Macros
--------------------------------------

A common practice in libraries is to craft a special macro that masks
a function.  This allows the faster macro to be substituted in code
that calls the function directly, but still allows a function pointer
to be referenced and passed around as well.  Hypocrite does an
``#undef`` on mocked functions, prior to creating its mock
``#define``, just before the ``#include`` of the target file, then
does an ``#undef`` again after the ``#include``.  This means that the
macro version of a function will be used in the mock declaration
itself, but only the underlying function will be visible to the rest
of the generated code, in particular the fixtures and the tests.

Mocking Macros
--------------

Macros that have no side effect are easy to mock, though it must be
noted that, because of the ``#undef`` mentioned above, those macros
won't be available in the rest of the generated test code.  However,
not all macros can be mocked this way.  Hypocrite's own
``hypo_assert()`` macro provides an example: this macro contains a
``return`` statement that would not be compatible with the wrapper
function generated by Hypocrite mock.  As such, these macros may not
be mockable, though the functions and macros they make use of may be.
