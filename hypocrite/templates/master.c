/* Copyright (C) 2017 by Kevin L. Mitchell <klmitch@mit.edu>
**
** Licensed under the Apache License, Version 2.0 (the "License"); you
** may not use this file except in compliance with the License. You
** may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
** implied. See the License for the specific language governing
** permissions and limitations under the License.
*/

%section header {
/* This file is automatically generated from {{source}}.
 *
 * To change this file, edit the source file and re-run hypocrite.
 */

%}

%insert header

%literal {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Structure for manipulating list-like data, such as lists of return
 * values or of call arguments.
 */
typedef struct {
  size_t size;
  unsigned int count;
  unsigned int capacity;
  unsigned char *storage;  /* unsigned char for convenience */
} _hypo_list_t;

/* Static initializer for _hypo_list_t */
#define _HYPO_LIST_INIT(type) {sizeof(type), 0, 0, 0}

/* Obtain the length of a _hypo_list_t */
#define _hypo_list_len(list) ((list)->count)

/* Obtain the item at the given index */
#define _hypo_list_ref(list, i)				\
  ((void *)((list)->storage + (list)->size * (i)))

/* Allocate an item in the list.  This may increase the capacity of
 * the list (factor-of-two logic is used).  If the system is out of
 * memory, this will abort().
 */
static void *
_hypo_list_alloc(_hypo_list_t *list)
{
  if (list->count + 1 >= list->capacity) {
    unsigned char *new;
    unsigned int new_capacity = list->capacity << 1;

    new = (unsigned char *)realloc(list->storage, list->size * new_capacity);
    if (!new) /* Not much else we can do */
      abort();

    /* realloc() can move the storage */
    list->storage = new;
    list->capacity = new_capacity;
  }

  return _hypo_list_ref(list, list->count++);
}

/* Clean up a list, releasing all memory */
#define _hypo_list_cleanup(list)		\
  do {						\
    free((list)->storage);			\
    (list)->count = 0;				\
    (list)->capacity = 0;			\
    (list)->storage = 0;			\
  } while (0)

/* A description of a test failure.  This will include the file and
 * line number of the failure, as well as the expression that failed
 * and what value it returned.  An optional "msg" is also present.
 */
typedef struct {
  const char *test_fname;
  const char *test;
  const char *file;
  unsigned int line;
  const char *expr;
  int value;
  const char *msg;
} _hypo_failure_t;

/* The test context.  This includes test flags and a list of failures.
 * Currently, the only defined flag is the FATAL flag, indicating that
 * an assertion was fatal; this will stop all further testing.
 */
typedef struct {
  unsigned int flags;
  const char *test_fname;
  const char *cur_test;
  _hypo_list_t failures;
} hypo_context_t;

#define _HYPO_FLAG_FATAL	0x00000001
#define _HYPO_FLAG_FAIL		0x00000002

/* The core assertion function.  Called with the location of the
 * assertion macro and all the interesting data (string form of the
 * expression, the evaluated expression, and an optional message).
 * Stores failures in the test context.
 */
static int
_hypo_assert(hypo_context_t *hypo_ctx, unsigned int flags,
	     const char *file, unsigned int line,
	     const char *expr, int value, const char *msg)
{
  _hypo_failure_t *failure;

  /* If the fatal flag is set, do nothing but bail out */
  if (hypo_ctx->flags & _HYPO_FLAG_FATAL)
    return 1;

  /* Successful assert? */
  if (value)
    return 0;

  /* Allocate a failure and record it */
  failure = (_hypo_failure_t *)_hypo_list_alloc(&hypo_ctx->failures);
  failure->test_fname = hypo_ctx->test_fname;
  failure->test = hypo_ctx->cur_test;
  failure->file = file;
  failure->line = line;
  failure->expr = expr;
  failure->value = value;
  failure->msg = msg;

  /* Flag that this test failed */
  hypo_ctx->flags |= _HYPO_FLAG_FAIL;

  /* If it was a fatal assertion, remember that */
  if (flags & _HYPO_FLAG_FATAL)
    hypo_ctx->flags |= _HYPO_FLAG_FATAL;

  /* Return true if it was fatal, so hypo_assert() can return */
  return hypo_ctx->flags & _HYPO_FLAG_FATAL;
}

/* Indicate a failure.  The required message must describe the
 * failure.
 */
#define hypo_fail(msg)					\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     0, 0, (msg)))			\
      return;						\
  } while (0)

/* Indicate a fatal failure.  The required message must describe
 * the failure.
 */
#define hypo_fail_fatal(msg)						\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     0, 0, (msg)))					\
      return;								\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().
 */
#define hypo_assert(expr)				\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     #expr, (expr), 0))			\
      return;						\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant allows the specification of an explanatory
 * message.
 */
#define hypo_assert_msg(expr, msg)			\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     #expr, (expr), (msg)))		\
      return;						\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant indicates a fatal assertion that will stop
 * all remaining testing.
 */
#define hypo_assert_fatal(expr)						\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     #expr, (expr), 0))					\
      return;								\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant indicates a fatal assertion that will stop
 * all remaining testing, as well as allowing the specification of an
 * explanatory message.
 */
#define hypo_assert_fatal_msg(expr, msg)				\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     #expr, (expr), (msg)))				\
      return;								\
  } while (0)

/* Helper macro for picking the minimum of two values. */
#define _hypo_min(a, b) ((a) < (b) ? (a) : (b))

/* Allow testing of targets containing main() functions. */
#define main _hypo_main

%}

%section target_include {
#include "{{target}}"
%}

%insert preamble
%insert mock_decl
%insert mock_install
%insert target_include
%insert mock_uninstall
%insert fixture_setup
%insert fixture_teardown
%insert test_decl

%literal {
static void
_hypo_mock_cleanup(void)
{
%}

%insert mock_cleanup

%literal {
}

int
_hypo_run_tests(hypo_context_t *ctx)
{
%}

%section init_runtests {
  ctx->test_fname = "{{test_fname}}";
%}

%insert init_runtests
%insert fixture_arg
%insert test_call

%literal {
  /* Clear the test name */
  hypo_ctx->cur_test = 0;

  return 1;
}

int
(main)(int argc, char **argv)
{
  hypo_context_t hypo_ctx = {0, 0, 0, _HYPO_LIST_INIT(_hypo_failure_t)};
  _hypo_failure_t *failure;
  int i, j, len;
  const char *last_test = 0;
  char star_buf[513], name_buf[513 - 4];

  /* Run the tests */
  if (!_hypo_run_tests(&hypo_ctx))
    printf("Testing halted due to fatal error in %s::%s\n",
	   hypo_ctx.test_fname, hypo_ctx.cur_test);

  /* Emit the test failure details */
  for (i = 0; i < _hypo_list_len(&hypo_ctx.failures); i++) {
    failure = (_hypo_failure_t *)_hypo_list_ref(
      &hypo_ctx.failures, i
    );

    /* Emit a detailed information header for test name changes */
    if (last_test != failure->test) {
      /* Construct the name string */
      len = snprintf(name_buf, sizeof(name_buf), "%s::%s",
		     failure->test_fname, failure->test);

      /* Construct the star buffer */
      for (j = 0; j < len + 4; j++)
	star_buf[j] = '*';
      star_buf[j] = '\0';

      /* Emit the name header */
      printf("\n%s\n* %s *\n%s\n\n", star_buf, name_buf, star_buf);

      /* Update the last_test so we don't output this ad nauseum */
      last_test = failure->test;
    }

    /* Now, report the failure */
    printf("%s:%d: ", failure->file, failure->line);
    if (failure->expr)
      printf("\"%s\" -> %d%s%s\n", failure->expr, failure->value,
	     failure->msg ? ": " : "", failure->msg ? failure->msg : "");
    else if (failure->msg)
      printf("%s\n", failure->msg);
    else
      printf("Unknown failure\n");
  }

  /* Return non-zero if there were any failures */
  return _hypo_list_len(&hypo_ctx.failures) ? 1 : 0;
}
%}
