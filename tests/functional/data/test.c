#line 17 "master.c.tmpl"
/* This file is automatically generated from test.hypo.
 *
 * To change this file, edit the source file and re-run hypocrite.
 */

#line 27 "master.c.tmpl"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Structure for manipulating list-like data, such as lists of return
 * values or of call arguments.
 */
typedef struct {
  size_t size;
  unsigned int count;
  unsigned int capacity;
  unsigned char *storage;  /* unsigned char for convenience */
} _hypo_list_t;

/* Static initializer for _hypo_list_t */
#define _HYPO_LIST_INIT(type) {sizeof(type), 0, 0, 0}

/* Obtain the length of a _hypo_list_t */
#define _hypo_list_len(list) ((list)->count)

/* Obtain the item at the given index */
#define _hypo_list_ref(list, i)				\
  ((void *)((list)->storage + (list)->size * (i)))

/* Allocate an item in the list.  This may increase the capacity of
 * the list (factor-of-two logic is used).  If the system is out of
 * memory, this will abort().
 */
static void *
_hypo_list_alloc(_hypo_list_t *list)
{
  if (list->count + 1 >= list->capacity) {
    unsigned char *new;
    unsigned int new_capacity = list->capacity << 1;

    new = (unsigned char *)realloc(list->storage, list->size * new_capacity);
    if (!new) /* Not much else we can do */
      abort();

    /* realloc() can move the storage */
    list->storage = new;
    list->capacity = new_capacity;
  }

  return _hypo_list_ref(list, list->count++);
}

/* Clean up a list, releasing all memory */
#define _hypo_list_cleanup(list)		\
  do {						\
    free((list)->storage);			\
    (list)->count = 0;				\
    (list)->capacity = 0;			\
    (list)->storage = 0;			\
  } while (0)

/* A description of a test failure.  This will include the file and
 * line number of the failure, as well as the expression that failed
 * and what value it returned.  An optional "msg" is also present.
 */
typedef struct {
  const char *test_fname;
  const char *test;
  const char *file;
  unsigned int line;
  const char *expr;
  int value;
  const char *msg;
} _hypo_failure_t;

/* The test context.  This includes test flags and a list of failures.
 * Currently, the only defined flag is the FATAL flag, indicating that
 * an assertion was fatal; this will stop all further testing.
 */
typedef struct {
  unsigned int flags;
  const char *test_fname;
  const char *cur_test;
  _hypo_list_t failures;
} hypo_context_t;

#define _HYPO_FLAG_FATAL	0x00000001
#define _HYPO_FLAG_FAIL		0x00000002

/* The core assertion function.  Called with the location of the
 * assertion macro and all the interesting data (string form of the
 * expression, the evaluated expression, and an optional message).
 * Stores failures in the test context.
 */
static int
_hypo_assert(hypo_context_t *hypo_ctx, unsigned int flags,
	     const char *file, unsigned int line,
	     const char *expr, int value, const char *msg)
{
  _hypo_failure_t *failure;

  /* If the fatal flag is set, do nothing but bail out */
  if (hypo_ctx->flags & _HYPO_FLAG_FATAL)
    return 1;

  /* Successful assert? */
  if (value)
    return 0;

  /* Allocate a failure and record it */
  failure = (_hypo_failure_t *)_hypo_list_alloc(&hypo_ctx->failures);
  failure->test_fname = hypo_ctx->test_fname;
  failure->test = hypo_ctx->cur_test;
  failure->file = file;
  failure->line = line;
  failure->expr = expr;
  failure->value = value;
  failure->msg = msg;

  /* Flag that this test failed */
  hypo_ctx->flags |= _HYPO_FLAG_FAIL;

  /* If it was a fatal assertion, remember that */
  if (flags & _HYPO_FLAG_FATAL)
    hypo_ctx->flags |= _HYPO_FLAG_FATAL;

  /* Return true if it was fatal, so hypo_assert() can return */
  return hypo_ctx->flags & _HYPO_FLAG_FATAL;
}

/* Indicate a failure.  The required message must describe the
 * failure.
 */
#define hypo_fail(msg)					\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     0, 0, (msg)))			\
      return;						\
  } while (0)

/* Indicate a fatal failure.  The required message must describe
 * the failure.
 */
#define hypo_fail_fatal(msg)						\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     0, 0, (msg)))					\
      return;								\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().
 */
#define hypo_assert(expr)				\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     #expr, (expr), 0))			\
      return;						\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant allows the specification of an explanatory
 * message.
 */
#define hypo_assert_msg(expr, msg)			\
  do {							\
    if (_hypo_assert(hypo_ctx, 0, __FILE__, __LINE__,	\
		     #expr, (expr), (msg)))		\
      return;						\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant indicates a fatal assertion that will stop
 * all remaining testing.
 */
#define hypo_assert_fatal(expr)						\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     #expr, (expr), 0))					\
      return;								\
  } while (0)

/* Assert that an expression is true.  This is similar in concept to
 * the standard C assert() macro, except that it does not call
 * abort().  This variant indicates a fatal assertion that will stop
 * all remaining testing, as well as allowing the specification of an
 * explanatory message.
 */
#define hypo_assert_fatal_msg(expr, msg)				\
  do {									\
    if (_hypo_assert(hypo_ctx, _HYPO_FLAG_FATAL, __FILE__, __LINE__,	\
		     #expr, (expr), (msg)))				\
      return;								\
  } while (0)

/* Helper macro for picking the minimum of two values. */
#define _hypo_min(a, b) ((a) < (b) ? (a) : (b))

/* Allow testing of targets containing main() functions. */
#define main _hypo_main

#line 6 "test.hypo"
#include <stdlib.h>

struct test_struct {
  unsigned int ts_value;
};
#line 214 "test.c"
#define ANYARG_FREE_PTR 0x00000001
#line 61 "mock-void.c.tmpl"

/* Represent calls that we expect to be made; the _any_flags element
 * can be used to indicate that we don't care about the value of a
 * specific argument.
 */
typedef struct {
  unsigned long _any_flags;
#line 224 "test.c"
void * ptr;
#line 69 "mock-void.c.tmpl"
} hypo_mock_expectcalls_free;

/* Represent actual calls to the mock.  The file and line from which
 * the call was made are recorded in the _file and _line elements.
 */
typedef struct {
  const char *_file;
  unsigned int _line;
#line 235 "test.c"
void * ptr;
#line 78 "mock-void.c.tmpl"
} hypo_mock_actualcalls_free;

/* Represent the state of the mock.  Keeps track of what the mock
 * should return, and what arguments it's been called with.
 */
static struct {
  int spy;
  _hypo_list_t calls;
} _hypo_mock_descriptor_free = {
  1, /* indicates "spy" mode */
  _HYPO_LIST_INIT(hypo_mock_actualcalls_free)
};

/* Implementation of the mock itself.  This is called by the mock
 * macro, and either calls the underlying function or returns the
 * configured return values.  Stores the call location and the
 * arguments the mock was called with.  This is the core of the mock
 * system.
 */
static void
_hypo_mock_free(const char *_file, unsigned int _line, void * ptr)
{
  hypo_mock_actualcalls_free *_call_storage;

  /* Store the call details */
  _call_storage = (hypo_mock_actualcalls_free*)_hypo_list_alloc(
    &_hypo_mock_descriptor_free.calls
  );
  _call_storage->_file = _file;
  _call_storage->_line = _line;
#line 268 "test.c"
_call_storage->ptr = ptr;
#line 109 "mock-void.c.tmpl"

  /* If in spy mode, call the underlying function */
  if (_hypo_mock_descriptor_free.spy)
    free(ptr);

  return;
}

/* Turn off spy mode for the mock. */
static void
hypo_mock_nospy_free(void)
{
  /* Switch to mock mode */
  _hypo_mock_descriptor_free.spy = 0;
}

/* Check the calls to the mock.  This walks through each of the
 * expected calls, verifying that it matches the corresponding actual
 * call to the mock.
 */
static void
_hypo_mock_checkcalls_free(
    hypo_context_t *hypo_ctx,
    hypo_mock_expectcalls_free *expected,
    unsigned int count
)
{
  unsigned int i, len;
  hypo_mock_actualcalls_free *actual;

  /* How many calls were there actually? */
  len = _hypo_list_len(&_hypo_mock_descriptor_free.calls);

  /* Verify we were called exactly count times */
  hypo_assert(count == len);

  /* Check each of the calls */
  for (i = 0; i < _hypo_min(count, len); i++) {
    actual = (hypo_mock_actualcalls_free *)_hypo_list_ref(
      &_hypo_mock_descriptor_free.calls, i
    );

#line 313 "test.c"
if (!(expected[i]._any_flags & ANYARG_FREE_PTR))
      hypo_assert(expected[i].ptr == actual->ptr);
#line 152 "mock-void.c.tmpl"
  }
}

/* The macro.  This is used to ensure that the hypocrite context is
 * passed to the _hypo_mock_checkcalls_free function.
 */
#define hypo_mock_checkcalls_free(expected, count)			\
  _hypo_mock_checkcalls_free(hypo_ctx, (expected), (count))

/* Retrieve the number of calls that have been made to the mock. */
#define hypo_mock_callcount_free()			\
  _hypo_list_len(&_hypo_mock_descriptor_free.calls)

/* Retrieve the Nth call description; this is an internal convenience
 * macro for building the macros for accessing the call arguments.
 */
#define _hypo_mock_getcall_free(i)			\
  ((hypo_mock_actualcalls_free *)_hypo_list_ref(	\
     &_hypo_mock_descriptor_free.calls, (i)		\
  ))

/* Get the file name from which the Nth call to the mock was made.
 * This will be "const char *".
 */
#define hypo_mock_getfile_free(i) (_hypo_mock_getcall_free(i)->_file)

/* Get the line number from which the Nth call to the mock was made.
 * This will be "int".
 */
#define hypo_mock_getline_free(i) (_hypo_mock_getcall_free(i)->_line)

/* Get the named argument for the Nth call to the mock.  This will be
 * whatever type was defined for that argument.  The argument name
 * must be a bare word specifying the argument name given when
 * declaring the mock.
 */
#define hypo_mock_getarg_free(i, arg)	\
  (_hypo_mock_getcall_free(i)->arg)

/* Clean up the mock.  This is called after every test function run
 * and ensures that the mock is returned to its initial state ("spy"
 * mode), not to mention releasing any memory allocated during the
 * test.
 */
static void
_hypo_mock_cleanup_free(void)
{
  /* Reset mock to "spy" mode */
  _hypo_mock_descriptor_free.spy = 1;

  /* And clean up the lists */
  _hypo_list_cleanup(&_hypo_mock_descriptor_free.calls);
}
#line 370 "test.c"
#define ANYARG_MALLOC_SIZE 0x00000001
#line 61 "mock.c.tmpl"

/* Represent calls that we expect to be made; the _any_flags element
 * can be used to indicate that we don't care about the value of a
 * specific argument.
 */
typedef struct {
  unsigned long _any_flags;
#line 380 "test.c"
size_t size;
#line 69 "mock.c.tmpl"
} hypo_mock_expectcalls_malloc;

/* Represent actual calls to the mock.  The file and line from which
 * the call was made are recorded in the _file and _line elements.
 */
typedef struct {
  const char *_file;
  unsigned int _line;
#line 391 "test.c"
size_t size;
#line 78 "mock.c.tmpl"
} hypo_mock_actualcalls_malloc;

/* Represent the state of the mock.  Keeps track of what the mock
 * should return, and what arguments it's been called with.
 */
static struct {
  int ret_idx;
  _hypo_list_t returns;
  _hypo_list_t calls;
} _hypo_mock_descriptor_malloc = {
  -1, /* indicates "spy" mode */
  _HYPO_LIST_INIT(void *),
  _HYPO_LIST_INIT(hypo_mock_actualcalls_malloc)
};

/* Implementation of the mock itself.  This is called by the mock
 * macro, and either calls the underlying function or returns the
 * configured return values.  Stores the call location and the
 * arguments the mock was called with.  This is the core of the mock
 * system.
 */
static void *
_hypo_mock_malloc(const char *_file, unsigned int _line, size_t size)
{
  void * _return_value;
  void * *_return_storage;
  hypo_mock_actualcalls_malloc *_call_storage;

  /* Store the call details */
  _call_storage = (hypo_mock_actualcalls_malloc*)_hypo_list_alloc(
    &_hypo_mock_descriptor_malloc.calls
  );
  _call_storage->_file = _file;
  _call_storage->_line = _line;
#line 428 "test.c"
_call_storage->size = size;
#line 113 "mock.c.tmpl"

  /* If in spy mode, call the underlying function */
  if (_hypo_mock_descriptor_malloc.ret_idx < 0) {
    _return_value = malloc(size);
    _return_storage = (void * *)_hypo_list_alloc(
      &_hypo_mock_descriptor_malloc.returns
    );
    *_return_storage = _return_value;
    return _return_value;
  }

  /* OK, not spy mode, pick the next mocked return value */
  _return_value = *((void * *)_hypo_list_ref(
    &_hypo_mock_descriptor_malloc.returns,
    &_hypo_mock_descriptor_malloc.ret_idx
  ));

  /* Advance the index if appropriate */
  if (_hypo_mock_descriptor_malloc.ret_idx + 1 <
      _hypo_list_len(&_hypo_mock_descriptor_malloc.returns))
    _hypo_mock_descriptor_malloc.ret_idx++;

  /* Return the mocked return value */
  return _return_value;
}

/* Add a return value for the mock to return.  The first time this is
 * called, the mock is forced out of "spy" mode.
 */
static void
hypo_mock_addreturn_malloc(void * return_value)
{
  void * *return_storage;

  /* Switch to mock mode */
  if (_hypo_mock_descriptor_malloc.ret_idx < 0)
    _hypo_mock_descriptor_malloc.ret_idx = 0;

  /* Add a return value */
  return_storage = (void * *)_hypo_list_alloc(
    &_hypo_mock_descriptor_malloc.returns
  );
  *return_storage = return_value;
}

/* Check the calls to the mock.  This walks through each of the
 * expected calls, verifying that it matches the corresponding actual
 * call to the mock.
 */
static void
_hypo_mock_checkcalls_malloc(
    hypo_context_t *hypo_ctx,
    hypo_mock_expectcalls_malloc *expected,
    unsigned int count
)
{
  unsigned int i, len;
  hypo_mock_actualcalls_malloc *actual;

  /* How many calls were there actually? */
  len = _hypo_list_len(&_hypo_mock_descriptor_malloc.calls);

  /* Verify we were called exactly count times */
  hypo_assert(count == len);

  /* Check each of the calls */
  for (i = 0; i < _hypo_min(count, len); i++) {
    actual = (hypo_mock_actualcalls_malloc *)_hypo_list_ref(
      &_hypo_mock_descriptor_malloc.calls, i
    );

#line 502 "test.c"
if (!(expected[i]._any_flags & ANYARG_MALLOC_SIZE))
      hypo_assert(expected[i].size == actual->size);
#line 185 "mock.c.tmpl"
  }
}

/* The macro.  This is used to ensure that the hypocrite context is
 * passed to the _hypo_mock_checkcalls_malloc function.
 */
#define hypo_mock_checkcalls_malloc(expected, count)			\
  _hypo_mock_checkcalls_malloc(hypo_ctx, (expected), (count))

/* Retrieve the number of calls that have been made to the mock. */
#define hypo_mock_callcount_malloc()			\
  _hypo_list_len(&_hypo_mock_descriptor_malloc.calls)

/* Retrieve the Nth return value of the mock. */
#define hypo_mock_getreturn_malloc(i)			\
  (*((void * *)_hypo_list_ref(			\
       &_hypo_mock_descriptor_malloc.returns, (i)	\
  )))

/* Retrieve the Nth call description; this is an internal convenience
 * macro for building the macros for accessing the call arguments.
 */
#define _hypo_mock_getcall_malloc(i)			\
  ((hypo_mock_actualcalls_malloc *)_hypo_list_ref(	\
     &_hypo_mock_descriptor_malloc.calls, (i)		\
  ))

/* Get the file name from which the Nth call to the mock was made.
 * This will be "const char *".
 */
#define hypo_mock_getfile_malloc(i) (_hypo_mock_getcall_malloc(i)->_file)

/* Get the line number from which the Nth call to the mock was made.
 * This will be "int".
 */
#define hypo_mock_getline_malloc(i) (_hypo_mock_getcall_malloc(i)->_line)

/* Get the named argument for the Nth call to the mock.  This will be
 * whatever type was defined for that argument.  The argument name
 * must be a bare word specifying the argument name given when
 * declaring the mock.
 */
#define hypo_mock_getarg_malloc(i, arg)	\
  (_hypo_mock_getcall_malloc(i)->arg)

/* Clean up the mock.  This is called after every test function run
 * and ensures that the mock is returned to its initial state ("spy"
 * mode), not to mention releasing any memory allocated during the
 * test.
 */
static void
_hypo_mock_cleanup_malloc(void)
{
  /* Reset mock to "spy" mode */
  _hypo_mock_descriptor_malloc.ret_idx = -1;

  /* And clean up the lists */
  _hypo_list_cleanup(&_hypo_mock_descriptor_malloc.returns);
  _hypo_list_cleanup(&_hypo_mock_descriptor_malloc.calls);
}
#line 208 "mock-void.c.tmpl"
#undef free
#define free(ptr)				\
  _hypo_mock_free(__FILE__, __LINE__(ptr))
#line 248 "mock.c.tmpl"
#undef malloc
#define malloc(size)				\
  _hypo_mock_malloc(__FILE__, __LINE__(size))
#line 229 "master.c.tmpl"
#include "to_test.c"
#line 214 "mock-void.c.tmpl"
#undef free
#line 254 "mock.c.tmpl"
#undef malloc
#line 21 "fixture.c.tmpl"
static test_struct *
hypo_fix_setup_allocate(hypo_context_t *hypo_ctx)
{
#line 17 "test.hypo"
  return (test_struct *)malloc(sizeof(struct test_struct));
#line 25 "fixture.c.tmpl"
}
#line 33 "fixture.c.tmpl"
static void
hypo_fix_teardown_allocate(hypo_context_t *hypo_ctx, test_struct * allocate)
{
#line 19 "test.hypo"
  free(allocate);
#line 37 "fixture.c.tmpl"
}
#line 23 "test.c.tmpl"
static void
hypo_test_allocate(hypo_context_t *hypo_ctx)
{
#line 23 "test.hypo"
  hypo_mock_expectcalls_malloc expected[] = {
    {0, sizeof(test_struct)}
  };
  struct test_struct test_data;
  struct test_struct *result;

  hypo_mock_addreturn_malloc(&test_data);

  result = alloc();

  hypo_assert(result == &test_data);
  hypo_mock_checkcalls_malloc(expected, 1);
#line 27 "test.c.tmpl"
}
#line 23 "test.c.tmpl"
static void
hypo_test_allocate_failure(hypo_context_t *hypo_ctx)
{
#line 38 "test.hypo"
  hypo_mock_expectcalls_malloc expected[] = {
    {0, sizeof(test_struct)}
  };
  struct test_struct *result;

  hypo_mock_addreturn_malloc(0);

  result = alloc();

  hypo_assert(result == 0);
  hypo_mock_checkcalls_malloc(expected, 1);
#line 27 "test.c.tmpl"
}
#line 23 "test.c.tmpl"
static void
hypo_test_deallocate(hypo_context_t *hypo_ctx, test_struct * allocate)
{
#line 52 "test.hypo"
  hypo_mock_expectcalls_free expected[] = {
    {0, allocate}
  };

  hypo_mock_nospy_free();

  dealloc(allocate);

  hypo_mock_checkcalls_free(expected, 1);
#line 27 "test.c.tmpl"
}
#line 242 "master.c.tmpl"
static void
_hypo_mock_cleanup(void)
{
#line 218 "mock-void.c.tmpl"
  _hypo_mock_cleanup_free();
#line 258 "mock.c.tmpl"
  _hypo_mock_cleanup_malloc();
#line 250 "master.c.tmpl"
}

int
_hypo_run_tests(hypo_context_t *ctx)
{
#line 258 "master.c.tmpl"
  ctx->test_fname = "test";
#line 41 "fixture.c.tmpl"
  test_struct * allocate;
#line 52 "test.c.tmpl"
  /* Save the test name */
  hypo_ctx->cur_test = "allocate";

  /* Let the user know what's being tested */
  printf("%s::%s... ", hypo_ctx->test_fname, hypo_ctx->cur_test);
  fflush(stdout);

  /* Initialize fixtures for allocate */
#line 676 "test.c"

#line 61 "test.c.tmpl"

  /* Run the test */
  hypo_test_allocate(hypo_ctx);

  /* Clean up the fixtures for allocate */
#line 684 "test.c"

#line 67 "test.c.tmpl"

  /* Finally, clean up the mocks for allocate */
  _hypo_mock_cleanup();

  /* Let the user know of the status of the test */
  printf((hypo_ctx->flags & _HYPO_FLAG_FAIL) ? "FAIL\n" : "PASS\n");
  hypo_ctx->flags &= ~_HYPO_FLAG_FAIL;

  /* Check if we encountered a fatal error while running allocate */
  if (hypo_ctx->flags & _HYPO_FLAG_FATAL)
    return 0;

#line 52 "test.c.tmpl"
  /* Save the test name */
  hypo_ctx->cur_test = "allocate_failure";

  /* Let the user know what's being tested */
  printf("%s::%s... ", hypo_ctx->test_fname, hypo_ctx->cur_test);
  fflush(stdout);

  /* Initialize fixtures for allocate_failure */
#line 708 "test.c"

#line 61 "test.c.tmpl"

  /* Run the test */
  hypo_test_allocate_failure(hypo_ctx);

  /* Clean up the fixtures for allocate_failure */
#line 716 "test.c"

#line 67 "test.c.tmpl"

  /* Finally, clean up the mocks for allocate_failure */
  _hypo_mock_cleanup();

  /* Let the user know of the status of the test */
  printf((hypo_ctx->flags & _HYPO_FLAG_FAIL) ? "FAIL\n" : "PASS\n");
  hypo_ctx->flags &= ~_HYPO_FLAG_FAIL;

  /* Check if we encountered a fatal error while running allocate_failure */
  if (hypo_ctx->flags & _HYPO_FLAG_FATAL)
    return 0;

#line 52 "test.c.tmpl"
  /* Save the test name */
  hypo_ctx->cur_test = "deallocate";

  /* Let the user know what's being tested */
  printf("%s::%s... ", hypo_ctx->test_fname, hypo_ctx->cur_test);
  fflush(stdout);

  /* Initialize fixtures for deallocate */
#line 740 "test.c"
  allocate = hypo_fix_setup_allocate(hypo_ctx);
#line 61 "test.c.tmpl"

  /* Run the test */
  hypo_test_deallocate(hypo_ctx, allocate);

  /* Clean up the fixtures for deallocate */
#line 748 "test.c"

#line 67 "test.c.tmpl"

  /* Finally, clean up the mocks for deallocate */
  _hypo_mock_cleanup();

  /* Let the user know of the status of the test */
  printf((hypo_ctx->flags & _HYPO_FLAG_FAIL) ? "FAIL\n" : "PASS\n");
  hypo_ctx->flags &= ~_HYPO_FLAG_FAIL;

  /* Check if we encountered a fatal error while running deallocate */
  if (hypo_ctx->flags & _HYPO_FLAG_FATAL)
    return 0;

#line 266 "master.c.tmpl"
  /* Clear the test name */
  hypo_ctx->cur_test = 0;

  return 1;
}

int
(main)(int argc, char **argv)
{
  hypo_context_t hypo_ctx = {0, 0, 0, _HYPO_LIST_INIT(_hypo_failure_t)};
  _hypo_failure_t *failure;
  int i, j, len;
  const char *last_test = 0;
  char star_buf[513], name_buf[513 - 4];

  /* Run the tests */
  if (!_hypo_run_tests(&hypo_ctx))
    printf("Testing halted due to fatal error in %s::%s\n",
	   hypo_ctx.test_fname, hypo_ctx.cur_test);

  /* Emit the test failure details */
  for (i = 0; i < _hypo_list_len(&hypo_ctx.failures); i++) {
    failure = (_hypo_failure_t *)_hypo_list_ref(
      &hypo_ctx.failures, i
    );

    /* Emit a detailed information header for test name changes */
    if (last_test != failure->test) {
      /* Construct the name string */
      len = snprintf(name_buf, sizeof(name_buf), "%s::%s",
		     failure->test_fname, failure->test);

      /* Construct the star buffer */
      for (j = 0; j < len + 4; j++)
	star_buf[j] = '*';
      star_buf[j] = '\0';

      /* Emit the name header */
      printf("\n%s\n* %s *\n%s\n\n", star_buf, name_buf, star_buf);

      /* Update the last_test so we don't output this ad nauseum */
      last_test = failure->test;
    }

    /* Now, report the failure */
    printf("%s:%d: ", failure->file, failure->line);
    if (failure->expr)
      printf("\"%s\" -> %d%s%s\n", failure->expr, failure->value,
	     failure->msg ? ": " : "", failure->msg ? failure->msg : "");
    else if (failure->msg)
      printf("%s\n", failure->msg);
    else
      printf("Unknown failure\n");
  }

  /* Return non-zero if there were any failures */
  return _hypo_list_len(&hypo_ctx.failures) ? 1 : 0;
}
